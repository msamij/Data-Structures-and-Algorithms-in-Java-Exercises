package exercises.reinforcement;

import java.util.Random;

import fundamentalDataStructures.CircularlyLinkedList;
import fundamentalDataStructures.DoublyLinkedList;
import fundamentalDataStructures.SinglyLinkedList;
import utilityClasses.TicTacToe;

public final class Reinforcement {
	private Reinforcement() {
	}

	/**
	 * R-3.1 Give the next five pseudorandom numbers generated by the process
	 * described on page 113, with a = 12, b = 5, and n = 100, and 92 as the seed
	 * for cur.
	 **/
	public static void reinforcement1() {
		int next = 0, a = 12, b = 5, cur = 92, n = 100;
		for (int i = 0; i < 5; i++) {
			next = (a * cur + b) % n;
			System.out.println(next);
			cur++;
		}
	}

	/**
	 * R-3.2 Write a Java method that repeatedly selects and removes a random entry
	 * from an array until the array holds no more entries.
	 **/
	public static void reinforcement2() {
		int[] myArray = { 1, 2, 3, 4, 5 };
		int rand = 0;
		Random random = new Random();
		random.setSeed(System.currentTimeMillis());

		boolean isEmpty = false;
		int counter = 0;
		while (!isEmpty) {
			rand = random.nextInt(myArray.length);
			if (myArray[rand] != 0) {
				myArray[rand] = 0;
				counter++;
			}
			if (counter == myArray.length)
				isEmpty = true;
		}

		for (int i : myArray) {
			System.out.println(i);
		}
	}

	/**
	 * R-3.3 Explain the changes that would have to be made to the program of Code
	 * Fragment 3.8 so that it could perform the Caesar cipher for messages that are
	 * written in an alphabet-based language other than English, such as Greek,
	 * Russian, or Hebrew.
	 */
	public static void reinforcement3() {
		/*
		 * We could replace everywheere first letter of english alphabet A with first
		 * letter of Greek Russian or Herbrew.
		 */
	}

	/**
	 * R-3.4 The TicTacToe class of Code Fragments 3.9 and 3.10 has a flaw, in that
	 * it allows a player to place a mark even after the game has already been won
	 * by someone. Modify the class so that the putMark method throws an
	 * IllegalStateException in that case.
	 */
	public static void reinforcement4() {
		TicTacToe game = new TicTacToe();
		game.putMark(0, 0);
		game.putMark(1, 0);
		game.putMark(1, 1);
		game.putMark(1, 2);
		game.putMark(2, 2);
		game.putMark(2, 0);

		System.out.println(game);
		int winningPlayer = game.winner();
		String[] outcome = { "O wins", "Tie", "X wins" }; // rely on ordering
		System.out.println(outcome[1 + winningPlayer]);
	}

	/**
	 * R-3.5 The removeFirst method of the SinglyLinkedList class includes a special
	 * case to reset the tail field to null when deleting the last node of a list.
	 * What are the consequences if we were to remove those two lines from the code?
	 * Explain why the class would or would not work with such a modification.
	 */
	public static void reinforcement5() {
		/*
		 * If we were to remove those two lines then tail would still point to a node,
		 * Which was also pointed by the head node. As an example if we only have a
		 * single node in the list then both head and tail would point to same node, Now
		 * when head reference was removed from that node tail must also be set to null
		 * otherwise that reference would still be there, eventhough list is now empty.
		 */
	}

	/**
	 * R-3.6 Give an algorithm for finding the second-to-last node in a singly
	 * linked list in which the last node is indicated by a null next reference.
	 */
	public static void reinforcement6() {
		SinglyLinkedList<Integer> singlyLinkedList = new SinglyLinkedList<>();
		singlyLinkedList.addFirst(1);
		singlyLinkedList.addLast(2);
		singlyLinkedList.addLast(3);
		singlyLinkedList.addLast(4);
		singlyLinkedList.addLast(5);
		System.out.println(singlyLinkedList.secondLast());
	}

	/**
	 * R-3.7 Consider the implementation of CircularlyLinkedList.addFirst, in Code
	 * The else body of that method relies on a locally declared variable, newest.
	 * Redesign that clause to avoid use of any local variable.
	 */
	public static void reinforcement7() {
		CircularlyLinkedList<Integer> circularlyLinkedList = new CircularlyLinkedList<>();
		circularlyLinkedList.addFirst(1);
		circularlyLinkedList.addLast(2);
		circularlyLinkedList.addLast(3);
		System.out.println(circularlyLinkedList.first());
	}

	/**
	 * R-3.8 Describe a method for finding the middle node of a doubly linked list
	 * with header and trailer sentinels by “link hopping,” and without relying on
	 * explicit knowledge of the size of the list. In the case of an even number of
	 * nodes, report the node slightly left of center as the “middle.” What is the
	 * running time of this method?
	 */
	public static void reinforcement8() {
		/*
		 * Running time of this algorithm for best case is O(1), If we only have single
		 * element. In worst case it runs O(N).
		 */
		DoublyLinkedList<Integer> doublyLinkedList = new DoublyLinkedList<>();
		doublyLinkedList.addFirst(1);
		doublyLinkedList.addLast(2);
		doublyLinkedList.addLast(3);
		doublyLinkedList.addLast(4);
		doublyLinkedList.addLast(5);
		System.out.println(doublyLinkedList.middle());
	}

	/**
	 * R-3.9 Give an implementation of the size() method for the
	 * SingularlyLinkedList class, assuming that we did not maintain size as an
	 * instance variable.
	 */
	public static void reinforcement9() {
		SinglyLinkedList<Integer> singlyLinkedList = new SinglyLinkedList<>();
		singlyLinkedList.addFirst(1);
		singlyLinkedList.addLast(2);
		singlyLinkedList.addLast(3);
		System.out.println(singlyLinkedList.sizeWithNoInstanceSizeVariable());
	}

	/**
	 * R-3.10 Give an implementation of the size() method for the
	 * CircularlyLinkedList class, assuming that we did not maintain size as an
	 * instance variable.
	 */
	public static void reinforcement10() {
		CircularlyLinkedList<Integer> circularlyLinkedList = new CircularlyLinkedList<>();
		circularlyLinkedList.addFirst(1);
		circularlyLinkedList.addLast(2);
		circularlyLinkedList.addFirst(0);
		circularlyLinkedList.addLast(3);
		System.out.println(circularlyLinkedList.sizeWithNoInstanceSizeVariable());
	}

	/**
	 * R-3.11 Give an implementation of the size( ) method for the DoublyLinkedList
	 * class, assuming that we did not maintain size as an instance variable.
	 */
	public static void reinforcement11() {
		DoublyLinkedList<Integer> doublyLinkedList = new DoublyLinkedList<>();
		doublyLinkedList.addFirst(1);
		doublyLinkedList.addLast(2);
		doublyLinkedList.addLast(3);
		doublyLinkedList.addLast(4);
		doublyLinkedList.addLast(5);
		System.out.println(doublyLinkedList.sizeWithNoInstanceSizeVariable());
	}

	/**
	 * R-3.12 Implement a rotate() method in the SinglyLinkedList class, which has
	 * semantics equal to addLast(removeFirst()), yet without creating any new
	 * node.
	 */
	public static void reinforcement12() {

	}
}
